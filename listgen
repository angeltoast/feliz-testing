#!/bin/bash

# Menu functions - listgen1 and listgen2
# Developed by Elizabeth Mills
# Revision date: 7th September 2016

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.

# A copy of the GNU General Public License is available from the Feliz2
# page at http://sourceforge.net/projects/feliz2/files
# or https://github.com/angeltoast/feliz2, or write to:
# The Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# See listgen.manual for further guidance

# Both functions return the name of the selected item using global variable $Result
# and item number as global variable $Response
# Window width and height are adjusted according to content

PrintOne() { # Aligned text according to screen size
  width=$(tput cols)
  EMPTY=" "
  lov=${#1}
  if [ ${lov} -lt ${width} ]; then
    stpt=$(( (width - lov) / 2 ))
    EMPTY="$(printf '%*s' $stpt)"
  fi
  echo "$EMPTY $1"
}

PrintMany() { # Subsequent item(s) in an aligned list
  echo "$EMPTY $1"
}

listgen1() { # Simple listing alternative to the bash 'select' function
# Arguments:
# 1) Primary file (string of single-word references)
# 2) Optional one-word --title
# 3) Optional hiding of <Cancel> ("nocancel")
# Read listgen.manual for full details
local Complete=0
while [ $Complete -eq 0 ]
do
  local Done=$3
  if [ $2 ]; then
    PrintOne $2
    Underscore=$(echo $2 | sed 's/./-/g')
    PrintOne $Underscore
  fi
  local Counter=0
  MenuList=$1
  for i in $MenuList
  do
    Counter=$((Counter+1))
    if [ $Counter -eq 1 ]; then
      PrintOne "$Counter) $i"
    else
      PrintMany "$Counter) $i"
    fi
    ConvertToArray[$Counter]=$i
  done
  case $Done in
    "") Counter=$((Counter+1))
        Done="Done"
        PrintMany "$Counter) Done"
    ;;
    "nodone") Done=""
    ;;
    *) Counter=$((Counter+1))
        PrintMany "$Counter) ${Done}"
  esac
  echo
  TPread "Please enter the number of your selection: "
  case $Response in
    ''|*[!0-9]*) invalid_option
    ;;
    *) if [ ${Response} -gt ${Counter} ] || [ ${Response} -lt 1 ]; then
        invalid_option
      elif [ ${Response} -eq ${Counter} ] && [ -z $Done ]; then
        Result=${ConvertToArray[${Response}]}
        Complete=1
      elif [ ${Response} -eq ${Counter} ]; then
        Result="$Done"
        Complete=1
      else
        Result=${ConvertToArray[${Response}]}
        Complete=1
      fi
  esac
  clear
done
}

listgen2() { # Advanced menuing function with extended descriptions
# Arguments:
# 1) Primary file (string of single-word references)
# 2) An optional one-word menu heading (which will be underlined on display)
# 3) Optional alternative word to 'Done'
# 4) Secondary file (the name of the array containing long descriptions)
# Read listgen.manual for full details
local Complete=0
while [ $Complete -eq 0 ]
do
  local Done=$3
  Result=""
  PrimaryFile="$1"
  name=$4[@]
  LongDescription=("${!name}")
  local Counter=0
  echo
  if [ -n $2 ]; then
    PrintOne $2
    Underscore=$(echo $2 | sed 's/./-/g')
    PrintOne $Underscore
  fi
  Counter=0
  for i in "${LongDescription[@]}"; do
    Counter=$((Counter+1))
    if [ $Counter -eq 1 ]; then
      PrintOne "${Counter}) $i"
    else
      PrintMany "${Counter}) $i"
    fi
  done
  case $Done in
    "") Counter=$((Counter+1))
        Done="Done"
        PrintMany "$Counter) Done"
    ;;
    "nodone") Done=""
    ;;
    *) Counter=$((Counter+1))
        PrintMany "$Counter) ${Done}"
  esac
  echo
  TPread "Please enter the number of your selection: "

   case $Response in
    ''|*[!0-9]*) invalid_option
    ;;
    *) if [ ${Response} -gt ${Counter} ]; then
      invalid_option
      elif [ ${Response} -eq ${Counter} ]; then
        Result="$Done"
        Complete=1
      else
        local Match=0
        for i in $PrimaryFile; do
          Match=$((Match+1))
          if [ $Match -eq $Response ]; then
            Result="$i"
          fi
        done
        Complete=1
      fi
  esac
  clear
done
}

#!/bin/bash

# The Feliz2 installation scripts for Arch Linux
# Developed by Elizabeth Mills
# Revision date: 4th December 2016

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.

# This program is distributed in the hope that it will be useful, but
#      WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#            General Public License for more details.

# A copy of the GNU General Public License is available from the Feliz2
#        page at http://sourceforge.net/projects/feliz2/files
#        or https://github.com/angeltoast/feliz2, or write to:
#                 The Free Software Foundation, Inc.
#                  51 Franklin Street, Fifth Floor
#                    Boston, MA 02110-1301 USA

# In this module: functions for setting variables used during installation
# --------------------   ------------------------
# Function        Line   Function            Line
# --------------------   ------------------------
# not_found         42    SetHostname         487
# Echo              47    PickLuxuries        504
# TPread            52    KeepOrDelete        536
# SetKernel         68    ShoppingList        563
# ConfirmVbox       81    ChooseDM            665
# getkeymap        105    SetGrubDevice       722
# setlocale        145     --- Review stage ---
# SetTimeZone      279    FinalCheck          746
# SelectSubZone    319    ManualSettings      853
# SetSubZone       328    ChangeRootPartition 876
# America          415    ChangeSwapPartition 884
# DoCities         446    ChangePartitions    892
# Username         471    AddExtras           904
# --------------------    -----------------------

not_found() {
  Echo
  read_timed "Not found. Please try again ..." 1
}

Echo() { # Use in place of echo for all screen display
  printf "%-s\n" "$1"
  cursor_row=$((cursor_row+1))
}

TPread() { # Aligned prompt for user-entry
  # $1 = prompt ... Returns result through $Response
  T_COLS=$(tput cols)
  lov=${#1}
  if [ ${lov} -lt ${T_COLS} ]; then
    stpt=$(( (T_COLS - lov) / 2 ))
  elif [ ${lov} -gt ${T_COLS} ]; then
    stpt=0
  else
    stpt=$(( (T_COLS - 10) / 2 ))
  fi
  EMPTY="$(printf '%*s' $stpt)"
  read -p "$EMPTY $1" Response
  cursor_row=$((cursor_row+1))
}

SetKernel() {
  print_heading
  Echo
  PrintOne "Choose your kernel"
  PrintOne "The Long-Term-Support kernel (LTS) offers stabilty,"
  PrintOne "while the Latest kernel has all the new features."
  PrintOne "If in doubt, choose LTS."
  Echo
  local Counter=0
  listgen1 "LTS Latest" "Kernels" "nocancel"
  Kernel=${Response} # Set the Kernel variable (1 = LTS; 2 = Latest)
}

ConfirmVbox() {
  while :
  do
    print_heading
    PrintOne "It appears that feliz is running in Virtualbox."
    PrintOne "If it is, feliz can install Virtualbox guest"
    PrintOne "utilities and make appropriate settings for you."
    Echo
    PrintOne "Install Virtualbox guest utilities?: "
    Echo
    Buttons "Yes/No" "[ Yes ] [ No ]" "Use arrow keys to move. [Enter] to select"
    Echo
    case $Response in
      1) IsInVbox="VirtualBox"
      ;;
      "") invalid_option
        continue
      ;;
      *) IsInVbox=""
    esac
    return 0
  done
}

getkeymap() {
  print_heading
  Echo
  PrintOne "Let's try to find your keyboard layout"
  while :
  do
    PrintOne "If you know the code for your keyboard layout, please enter"
    PrintOne "it now. If not, try entering a two-letter abbreviation for"
    PrintOne "your country or language and a list will be displayed. If"
    PrintOne "your keyboard is not listed, select [ Exit ] to try again."
    Echo
    TPread "(eg: 'dvorak' or 'us'): "
    local Term="${Response,,}"
    Echo
    ListKbs=$(cat keymaps.list | grep ${Term})
    if [ -n "${ListKbs}" ]; then  # If a match or matches found
      print_heading
      PrintOne "Select your keyboard, or [ Exit ] to try again"
      listgen1 "$ListKbs" "" ""
      if [ ${Result} = "Exit" ]; then
        print_heading
        Echo
        continue
      else
        Countrykbd="${Result}"
      fi
      loadkeys ${Countrykbd} 2>> feliz.log
      break
    else
      print_heading
      Echo
      PrintOne "No keyboards found containing '$Term'"
      PrintOne "Please try again"
      continue
    fi
  done
  print_heading
  read_timed "The keyboard is now set to: '$Countrykbd'" 1
}

setlocale() {
  SearchPrompt=" (for example: GB or PT): "
  City=$SUBZONE                                     # Use a copy of $SUBZONE set in SetTimeZone
  while :
  do
    print_heading
    PrintOne "Next we will try to find your locale. This will"
    PrintOne "be used to set fonts and language, and to find"
    PrintOne "the best mirrors for downloading your system"
    if [ $City ] && [ -n "$City" ]; then            # If subzone found  ...
      cityfile=$(cat cities.list | grep "$City")    # Try to find $City in cities.list
                                                    # The characters up to the ':' are the city name
                                                    # cityname=$(echo "${cityfile%%:*}")
      SEARCHTERM=$(echo "${cityfile##*:}")          # The characters after the ':' are the country code
      SEARCHTERM=${SEARCHTERM:0:2}                  # Ensure no trailing spaces
      if [ $SEARCHTERM ]; then
        Echo
        PrintOne "Country code: $SEARCHTERM found from your city: ${City}."
        PrintOne "Shall we use this as your locale?"  # Allow user to confirm
        Buttons "Yes/No" "[ Yes ] [ No ]" "Use arrow keys to move. [Enter] to select"
      else
        Response=2
      fi
      if [ $Response -eq 2 ]; then
        City=""
        continue
      fi
    else                                            # If not found, user will have to enter country code
      Echo
      PrintOne "Please enter a two-letter code for your country."
      Echo
      TPread "$SearchPrompt"                        # Could be GB or gb
      if [ -z ${Response} ]
      then
        invalid_option
        continue
      else
        Echo
        Response="${Response:0:2}"                  # Make sure only two characters
        SEARCHTERM="${Response^^}"                  # Set to all uppercase
      fi
    fi
    LocaleList=$(grep ${SEARCHTERM}.UTF-8 /etc/locale.gen | grep -v "@" | sed 's/\..*$//' | sed 's/#//g' | awk '{print $1}' | sort | uniq)      # Find all matching entries in locale.gen
    local Counter=0                                 # This will be a table of locales in the
    localelist=""                                   # form cy_GB en_GB gd_GB ...
    for l in ${LocaleList[@]}
    do
      localelist="${localelist} $l"                 # Add each item to text list for handling
      Counter=$((Counter+1))
    done
    if [ $Counter -eq 0 ]; then                     # If none found, try again
      not_found
      continue
    fi
    Counted=$(echo $localelist | wc -w)             # Count number of words in $localelist
    Newlist=""
    for (( i=1; i <= Counted; ++i ))                # Get list of all languages for locale
    do
      loc=$(echo $localelist | awk "{print \$$i}")  # Save the $i item from localelist to Newlist
      Newlist="$Newlist ${loc:0:2}"                 # First two characters are language code
    done
    if [ $i -lt 2 ]; then                           # No language code found
      not_found
      continue
    elif [ $i -lt 3 ]; then                         # Only one language code found
      Echo
      Item=$(echo ${Newlist} | xargs)               # Trim any leading and trailing spaces
      Language="$(grep $Item\$ languages.list | awk 'BEGIN { FS = ":"; OFS = ":" } {print $1}')"
      PrintOne "Only one language found for your location: $Language"
      PrintOne "Shall we use this as your language?"  # Allow user to confirm
      Buttons "Yes/No" "[ Yes ] [ No ]" "Use arrow keys to move. [Enter] to select"
      if [ $Response -eq 2 ]; then
        City=""
        continue
      else
        CountryLocale="${Item}_${SEARCHTERM}.UTF-8"
        CountryCode=${CountryLocale:3:2}                     # 2 characters from position 3
        break
      fi
    else
      localelist="${Newlist}"
    fi
    Newlist=""
    Prev="xyz"
    for l in $localelist                                    # Remove any duplicates
    do
      if [ $l != $Prev ]; then
        Newlist="$Newlist $l"
        Prev=$l
      fi
    done
    localelist="${Newlist}"                                 # Copy to working variable
    choosefrom=""
    Newlist=""
    Counter=0                         # Prepare to limit length of file
    local Rows=$(tput lines)          # to ensure list doesn't over-run
    Rows=$((Rows-2))                  # Available (printable) rows
    for l in ${localelist}
    do
      Item="$(grep $l\$ languages.list | awk 'BEGIN { FS = ":"; OFS = ":" } {print $1}')" # Find the language
      if [ $Item ]; then
        choosefrom="$choosefrom $Item"                    # Create a list of languages for user
        Newlist="$Newlist $l"                             # ... and a matching list of codes
      fi
      Counter=$((Counter+1))
    done
    localelist="${Newlist}"                               # Ensure that localelist matches choosefrom
    print_heading
    PrintOne "Now please choose your language from this list, or [ Exit ] to try again."
    if [ $Counter -ge $Rows ]; then
      listgenx "${choosefrom}" "nomessage" ""            # Alternative (numbered) list
    else
      listgen1 "${choosefrom}" "nomessage" ""
    fi
    case $Result in
    "Exit") Echo
    ;;
    *) Counted=1
      for l in ${localelist}
      do
        if [ $Counted -eq $Response ]; then
          break
        fi
        Counted=$((Counted+1))
      done
      CountryLocale="${l}_${SEARCHTERM}.UTF-8"
      CountryCode=${CountryLocale:3:2}                        # 2 characters from position 3
      break
    esac
  done
  print_heading
  read_timed "Locale is set to: ${CountryLocale:0:5}" 1       # 5 characters from position 0 in $CountryLocale
}

SetTimeZone() {
  SUBZONE=""
  while [ -z $SUBZONE ]
  do
    print_heading
    PrintOne "To set the system clock, please first"
    PrintOne "choose the World Zone of your location."
    Zones=$(timedatectl list-timezones | sed 's/\/.*$//' | uniq) # Ten world zones
    Echo
    zones=""
    for x in ${Zones[@]}                      # Convert to space-separated list
    do
      zones="$zones $x"
    done
    listgen1 "${zones}" "" "nocancel"         # Allow user to select one
    ZONE=$Result
    Echo
    case $Result in                           # UTC requires no subzone
      "UTC") SUBZONE=""
          print_heading
          read_timed "Zone set to: '$ZONE'" 1 # Display and exit
          break
      ;;
      *) SetSubZone                           # Call subzone function
        case $SUBZONE in                      # If user elects to change zone
        "Exit") SUBZONE=""
            continue
      ;;
      "") continue                            # ... or if escape, etc
      ;;
      *) print_heading                        # Should be complete
          read_timed "Zone and Subzone set to: '$ZONE/$SUBZONE'" 1
        esac
    esac
  done
}

SetSubZone() {  # Use ZONE set in SetTimeZone to list available subzones
  SubZones=$(timedatectl list-timezones | grep ${ZONE}/ | sed 's/^.*\///')
  Ocean=0
  SUBZONE=""
  while [ -z $SUBZONE ]
  do
    case $ZONE in
    "Antarctica") SelectSubzone
    ;;
    "Arctic") SUBZONE="Longyearbyen"
    ;;
    "Atlantic") Ocean=1
      SelectSubzone
    ;;
    "Australia") Ocean=1
      SelectSubzone
    ;;
    "Indian") Ocean=1
      SelectSubzone
    ;;
    "Pacific") Ocean=1
      SelectSubzone
    ;;
    "America") America
     ;;
    *)  SelectSubzone
    esac
  done
}

SelectSubzone() {
  print_heading
  case $Ocean in
  1) PrintOne "Now we need to find your location in the $ZONE"
      PrintOne "ocean. Please enter the first letter of the island"
      PrintOne "or group where you are located."
    ;;
  *) PrintOne "Now we need to find your location in $ZONE"
    PrintOne "Please enter the first letter of your nearest major city"
  esac
  PrintOne "... or leave blank to select another world zone"
  Echo
  FindCity
}

America() {
  SUBZONE=""      # Make sure this variable is empty
  print_heading
  PrintOne "Are you in any of these states?"
  SubList=""      # Start an empty list
  Previous=""     # Prepare to save previous record
  local Toggle="First"
  for i in $(timedatectl list-timezones | grep "$ZONE/" | awk 'BEGIN { FS = "/"; OFS = "/" } {print $2}')
  do
    if [ $Previous ] && [ $i = $Previous ] && [ $Toggle = "First" ]; then # First reccurance
      SubList="$SubList $i"
      Toggle="Second"
    elif [ $Previous ] && [ $i != $Previous ] && [ $Toggle = "Second" ]; then # 1st occ after prev group
      Toggle="First"
      Previous=$i
    else                                                                  # Subsequent occurances
      Previous=$i
    fi
  done
  SubGroup=""
  SubList="$SubList None_of_these"        # Add a decline option
  listgen1 "$SubList"
  case $Result in
  "None_of_these") SelectSubzone          # No subgroup, call general city function
  ;;
  "Exit") SetTimeZone
  ;;
  *) SubGroup=$Result                     # Save subgroup for next function
    ZONE="${ZONE}/$SubGroup"              # Add subgroup to ZONE
    DoCities                              # City function for subgroups
  esac
}

FindCity() {  # Called by SelectSubzone
  TPread "Please enter the initial letter: "
  Echo
  if [ -z ${Response} ]
  then
    SUBZONE=""
    SetTimeZone
  else
    Response="${Response:0:1}"        # In case user enters more than one letter
    Zone2="${Response^^}"             # Convert the first letter to upper case
  fi
  subzones=""
  local Rows=$(tput lines)            # Used to allow for longer (numbered) lists
  Rows=$((Rows-6))                    # Available (printable) rows
  local Counter=0
  for x in ${SubZones[@]}             # Search long list of subzones that match ZONE
  do                                  # to find those that start with user's letter
    if [ ${x:0:1} = ${Zone2} ]; then  # If first character in subzone matches ...
      subzones="$subzones $x"         # Save to list
      Counter=$((Counter+1))
    fi
  done
  if [ ${Counter} -eq 0 ]; then       # None found
    not_found
    continue
  fi
  print_heading
  PrintOne "Now choose your nearest location from this list"
  PrintOne "... or [ Exit ] to try again if it is not there"
  if [ $Counter -ge $Rows ]; then
    listgenx "$subzones" "" ""
  else
    listgen1 "$subzones" "nomessage" ""
  fi
  case $Result in
    "Exit") SUBZONE=""
    ;;
    *) SUBZONE=$Result
  esac
}

DoCities() { # Specifically for America, which has subgroups
  print_heading
  Cities=""
  case $SubGroup in
  "") # No subgroup selected. Here we are working on the second field - cities without a subgroup
      for i in $(timedatectl list-timezones | grep "$ZONE/" | awk 'BEGIN { FS = "/"; OFS = "/" } {print $2}')
      do
        Cities="$Cities $i"
      done
  ;;
  *) # Here we are working on the third field - cities within the chosen subgroup
      for i in $(timedatectl list-timezones | grep "$ZONE/" | awk 'BEGIN { FS = "/"; OFS = "/" } {print $3}')
      do
        Cities="$Cities $i"
      done
  esac
  PrintOne "Please select a city from this list"
  listgen1 "$Cities"
  case $Result in
  "Exit") SetTimeZone
  ;;
  *) SUBZONE=$Result
  esac
}

UserName() {
  print_heading
  PrintOne "Enter a name for the primary user of the new system."
  PrintOne "If you don't create a username here, a default user"
  PrintOne "called 'archie' will be set up"
  Echo
  TPread "User Name: "
  Entered=${Response,,}
  case $Entered in
    "") UserName="archie"
    ;;
    *) UserName=${Entered}
  esac
  PrintOne "User '${UserName}' will be created."
}

SetHostname() {
  Entered="arch-linux"
  print_heading
  PrintOne "A hostname is needed. This will be a unique name to identify"
  PrintOne "your device on a network. If you do not enter one, the"
  PrintOne "default hostname of 'arch-linux' will be used."
  Echo
  TPread "Enter a hostname for your computer: "
  Entered=${Response,,}
  case $Entered in
    "") HostName="arch-linux"
    ;;
    *) HostName=${Entered}
  esac
  PrintOne "Hostname = $HostName"
}

PickLuxuries() { # User selects any combination from a store of extras
  CategoriesList="Accessories Desktop_Environments Graphical Internet Multimedia Office Programming Window_Managers"
  print_heading
  case "$LuxuriesList" in
  "") PrintOne "Now you have the option to add extras, such as a web browser,"
    PrintOne "desktop environment, etc, from the following categories."
    PrintOne "If you want only a base Arch installation, exit without choosing any extras."
  ;;
  *) PrintOne "You can add more items, or select items to delete."
  esac
  Echo
  while :
  do
    listgen1 "${CategoriesList}" "" ""
    Category=$Response
    if [ $Result = "Exit" ]; then
      break
    else
      ShoppingList
      print_heading
      PrintOne "Added so far:: ${LuxuriesList}"
      PrintOne "You can now choose from any of the other lists,"
      PrintOne "or choose [ Exit ] to finish this part of the setup."
    fi
  done
  if [ -n "${LuxuriesList}" ]; then
    Scope="Full"
  else
    Scope="Basic"
  fi
}

KeepOrDelete() {
  Bagged="$1"
  while :
  do
    print_heading
    Message="$Bagged is already in your shopping list."
    Buttons "Yes/No" "[ Keep ] [ Delete ]" "Use arrow keys to move. [Enter] to select"
    case $Response in
      1) Temp="$LuxuriesList"
        break
      ;;
      2) Validated="Y"
        Temp=""
        for lux in $LuxuriesList
        do
          if [ ${lux} != ${Bagged} ]; then
            Temp="$Temp $lux"
          fi
        done
        break
      ;;
      *) invalid_option
    esac
  done
  LuxuriesList="$Temp"
}

ShoppingList() { # Called by PickLuxuries after a category has been chosen.
  Passed="Choose your first item"
  while :
  do
    print_heading
    PrintOne "Added so far: ${LuxuriesList}"
    Echo
    PrintOne "${Categories[$Category]}" # $Category is number of item in CategoriesList
    # Pass category to listgen2 for user to choose one item;
    local Counter=1
    case $Category in
       1) for i in ${Accessories}
          do
           LongAccs1[${Counter}]="$i - ${LongAccs[${Counter}]}"
           (( Counter+=1 ))
          done
         listgen2 "$Accessories" "" "" "LongAccs1"
       ;;
       2) for i in ${Desktops}
          do
           LongDesk1[${Counter}]="$i - ${LongDesk[${Counter}]}"
           (( Counter+=1 ))
          done
         listgen2 "$Desktops" "" "" "LongDesk1"
       ;;
       3) for i in ${Graphical}
          do
            LongGraph1[${Counter}]="$i - ${LongGraph[${Counter}]}"
           (( Counter+=1 ))
          done
           listgen2 "$Graphical" "" "" "LongGraph1"
       ;;
       4) for i in ${Internet}
          do
           LongNet1[${Counter}]="$i - ${LongNet[${Counter}]}"
            (( Counter+=1 ))
         done
         listgen2 "$Internet" "${Headline}" "" "LongNet1"
       ;;
       5) for i in ${Multimedia}
          do
            LongMulti1[${Counter}]="$i - ${LongMulti[${Counter}]}"
            (( Counter+=1 ))
          done
          listgen2 "$Multimedia" "" "" "LongMulti1"
       ;;
       6) for i in ${Office}
          do
            LongOffice1[${Counter}]="$i - ${LongOffice[${Counter}]}"
            (( Counter+=1 ))
          done
          listgen2 "$Office" "" "" "LongOffice1"
       ;;
       7) for i in ${Programming}
          do
            LongProg1[${Counter}]="$i - ${LongProg[${Counter}]}"
            (( Counter+=1 ))
          done
          listgen2 "$Programming" "" "" "LongProg1"
       ;;
       8) for i in ${WindowManagers}
          do
            LongWMs1[${Counter}]="$i - ${LongWMs[${Counter}]}"
            (( Counter+=1 ))
          done
          listgen2 "$WindowManagers" "" "" "LongWMs1"
      ;;
      *) break
    esac
    Passed="Choose your next item" # Loop until user selects "Exit"
    if [ $Result = "Exit" ]; then
      break
    fi
    AddToList="Y"
    # First check that chosen item is not already on the list
    for lux in $LuxuriesList
    do
      if [ ${lux} = ${Result} ]; then
        KeepOrDelete "$Result" # New function
        Result=""
        continue
      fi
    done
    # Then carry out any specific tests and add the item to the list
    SaveResult=$Result # (Because other subroutines return $Result)
    case $SaveResult in
      "Budgie" | "Cinnamon" | "Deepin" | "Enlightenment" | "Fluxbox" | "Gnome" | "KDE" | "LXDE" | "LXQt" |  "Mate" | "Openbox" | "Xfce") DesktopEnvironment=$SaveResult

       ;;
      "") continue
       ;;
      *) Echo
    esac
    if [ ${SaveResult} = "libreoffice" ]; then
      LuxuriesList="${LuxuriesList} libreoffice-fresh"
    else
      LuxuriesList="${LuxuriesList} ${SaveResult}"
    fi
  done
  Passed=""     # Clear the information variable
}

ChooseDM() { # Choose a display manager
  case $DisplayManager in
  "") # Only offered if no other display manager has been set
      Counter=0
      Greeter=""
      DMList="GDM LightDM LXDM sddm SLIM XDM"
      print_heading
      PrintOne "A display manager provides a graphical login screen."
      PrintOne "If in doubt, choose LightDM."
      PrintOne "If you do not install a display manager, you will have"
      PrintOne "to launch your desktop environment manually."
      Echo
      listgen1 "${DMList}" "" ""
      Reply=$Response
      for item in ${DMList}
      do
        Counter=$((Counter+1))
        if [ $Counter -eq $Reply ]
        then
          SelectedDM=$item
          case $SelectedDM in
            "GDM") DisplayManager="gdm"
              ;;
            "LightDM") DisplayManager="lightdm"
                  Greeter="lightdm-gtk-greeter"
              ;;
            "LXDM") DisplayManager="lxdm"
              ;;
            "sddm") DisplayManager="sddm"
              ;;
            "SLIM") DisplayManager="slim"
              ;;
            "XDM") DisplayManager="xdm"
              ;;
            *) DisplayManager=""
          esac
          break
        fi
      done
    ;;
  *) # Warn that DM already set, and offer option to change it
      print_heading
      PrintOne "Display manager is already set as: $DisplayManager."
      PrintOne "Only one display manager can be active"
      Echo
      PrintOne "Do you wish to change it?: "
      Echo
      Buttons "Yes/No" "[ Yes ] [ No ]" "Use arrow keys to move. [Enter] to select"
      Echo
      if [ $Response -eq 1 ]; then    # User wishes to change DM
        DisplayManager=""             # Clear DM variable
        Greeter=""                    # and greeter
        ChooseDM                      # Call this function again
      fi
  esac
}

SetGrubDevice() {
  DEVICE=""
  DevicesList="$(lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd')";
  print_heading
  GrubDevice=""
  local Counter=0
  PrintOne "Select the device where Grub is to be installed."
  PrintOne "Note that if you do not select a device, Grub"
  PrintOne "will not be installed, and you will have to make"
  PrintOne "alternative arrangements for booting your new system."
  Echo
  listgen1 "${DevicesList}" "" ""
  Reply=$Response
  for i in ${DevicesList}
  do
    Item=$i
    Counter=$((Counter+1))
    if [ $Counter -eq $Reply ]; then
      GrubDevice=$Item
      break
    fi
  done
}

FinalCheck() {
  while :
  do
    print_heading
    PrintOne "These are the settings you have entered. Please check them ..."
    Echo
    if [ ${UEFI} -eq 1 ]; then
      PrintOne "0)  Boot partition ... $EFIPartition             "
      PrintMany "1)  Root partition ... $RootPartition : $RootType"
    else
      PrintOne "1)  Root partition ... $RootPartition : $RootType"
    fi
    if [ $SwapPartition ] || [ $SwapFile ]; then
      PrintMany "2)  Swap partition ... $SwapPartition $SwapFile"
    else
      PrintMany "2)  No provision has been made for swap"
    fi
    if [ ${#AddPartList[@]} -gt 0 ]; then
      Counter=0
      PrintMany "3)  Extra partitions ..."
      for i in ${AddPartList[@]}
      do
        PrintMany "     ${AddPartMount[$Counter]} : ${AddPartList[$Counter]} : ${AddPartType[$Counter]}"
        Counter=$((Counter+1))
      done
    else
      PrintMany "3)  No additional partitions have been allocated"
    fi
    case $Kernel in
      1) PrintMany "4)  The LTS kernel will be installed"
      ;;
      *) PrintMany "4)  The latest kernel will be installed"
    esac
    if [ $GrubDevice ]; then
    PrintMany "5)  Grub will be installed to $GrubDevice"
    else
      PrintMany "5)  No provision has been made for Grub"
    fi
    PrintMany "6)  Keyboard is $Countrykbd"
    PrintMany "7)  Locale will be set to $CountryLocale"
    PrintMany "8)  Zone/subZone will be $ZONE/$SUBZONE"
    case ${IsInVbox} in
      "VirtualBox") PrintMany "9)  Virtualbox guest utilities will be installed"
      ;;
      *) PrintMany "9)  Virtualbox guest utilities will not be installed"
    esac
    if [ -z $DisplayManager ]; then
      PrintMany "10)  No Display Manager selected"
    else
      PrintMany "10)  Display Manager = $DisplayManager"
    fi
    PrintMany "11)  Root and user settings ..."
    PrintMany "     Hostname = '$HostName'"
    PrintMany "     User = '$UserName'"
    PrintMany "12) The following extras have been selected ..."
    PrintOne "${LuxuriesList}"
    Echo
    PrintOne "Press [Enter] to install with these settings, or"
    Response=20
    TPread "enter an item number if you wish to change it: "
    Change=$Response
    case $Change in
      1) ChangeRootPartition
        AllocateRoot
        continue
      ;;
      2) ChangeSwapPartition
        AllocateSwap
        continue
      ;;
      3) ChangePartitions
        MorePartitions
        continue
      ;;
      4) SetKernel
        continue
      ;;
      5) SetGrubDevice
        continue
      ;;
      6) getkeymap
        continue
      ;;
      7) setlocale
        continue
      ;;
      8) SetTimeZone
        continue
      ;;
      9) ConfirmVbox
        continue
      ;;
      10) DisplayManager=""
        ChooseDM
        continue
      ;;
      11) ManualSettings
        continue
      ;;
      12) PickLuxuries
        continue
      ;;
      *) break
    esac
  done
}

ManualSettings() {
  while :
  do
    print_heading
    PrintOne "Enter number for data to change, or [Enter] to finish:"
    Echo
    PrintOne "1) Hostname (currently $HostName)"
    PrintMany "2) Username (currently $UserName)"
    Echo
    TPread "Enter the number of your selection : "
    Echo
    case $Response in
      1) TPread "Enter new Hostname (currently $HostName) : "
         HostName=$Response
        ;;
      2) TPread "Enter new username to be created (currently $UserName) : "
         UserName=$Response
        ;;
      *) return 0
    esac
  done
}

ChangeRootPartition() {
# Start array with SwapPartition
  Ignorelist[0]=${SwapPartition}
  local Counter=1
  AddExtras
  MakePartitionList
}

ChangeSwapPartition() {
# Start array with RootPartition
  Ignorelist[0]=${RootPartition}
  Counter=1
  AddExtras
  MakePartitionList
}

ChangePartitions() {
  # Copy RootPartition and SwapPartition into temporary array
  Ignorelist[0]=${RootPartition}
  local Counter=1
  if [ ${SwapPartition} ]; then
    Ignorelist[1]=${SwapPartition}
    Counter=2
  fi
  Ignores=${#Ignorelist[@]} # Save a count for later
  MakePartitionList
}

AddExtras() {
  # Ignorelist started and Counter set to next record number by calling
  # function ChangeSwapPartition or ChangeRootPartition
  # Add each field (extra partition) from AddPartList into the array:
  for a in ${AddPartList[@]}; do
    Ignorelist[$Counter]=$a
    Counter=$((Counter+1))
  done
  Ignores=${#Ignorelist[@]} # Save a count for later
}

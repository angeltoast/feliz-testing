#!/bin/bash

# The Feliz2 installation scripts for Arch Linux
# Developed by Elizabeth Mills
# Revision date: 4th December 2016

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.

# This program is distributed in the hope that it will be useful, but
#      WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#            General Public License for more details.

# A copy of the GNU General Public License is available from the Feliz2
#        page at http://sourceforge.net/projects/feliz2/files
#        or https://github.com/angeltoast/feliz2, or write to:
#                 The Free Software Foundation, Inc.
#                  51 Franklin Street, Fifth Floor
#                    Boston, MA 02110-1301 USA

# In this module: functions for setting variables used during installation
# --------------------   ------------------------
# Function        Line   Function            Line
# --------------------   ------------------------
# invalid_option    39    KeepOrDelete        315
# TPread            44    ShoppingList        376
# SetKernel         59    ChooseDM            401
# ConfirmVbox       75    SetGrubDevice       549
# getkeymap        100     --- Review stage ---
# setlocale        138    FinalCheck          577
# SetTimeZone      195    ManualSettings      682
# SetSubZone       208    ChangeRootPartition 708
# Username         248    ChangeSwapPartition 716
# Hostname         264    ChangePartitions    724
# PickLuxuries     280    AddExtras           736
# --------------------    -----------------------

invalid_option() {
  Echo
  read_timed "Invalid entry. Please try again ..." 1
}

not_found() {
  Echo
  read_timed "Not found. Please try again ..." 1
}

Echo() { # Use in place of echo for all screen display
  printf "%-s\n" "$1"
  cursor_row=$((cursor_row+1))
}

TPread() { # Aligned prompt for user-entry
  # $1 = prompt ... Returns result through $Response
  T_COLS=$(tput cols)
  lov=${#1}
  if [ ${lov} -lt ${T_COLS} ]; then
    stpt=$(( (T_COLS - lov) / 2 ))
  elif [ ${lov} -gt ${T_COLS} ]; then
    stpt=0
  else
    stpt=$(( (T_COLS - 10) / 2 ))
  fi
  EMPTY="$(printf '%*s' $stpt)"
  read -p "$EMPTY $1" Response
  cursor_row=$((cursor_row+1))
}

SetKernel() {
  print_heading
  Echo
  PrintOne "Choose your kernel"
  PrintOne "The Long-Term-Support kernel (LTS) offers stabilty,"
  PrintOne "while the Latest kernel has all the new features."
  PrintOne "If in doubt, choose LTS."
  Echo
  local Counter=0
  listgen1 "LTS Latest" "Kernels" "nocancel"
  Kernel=${Response} # Set the Kernel variable (1 = LTS; 2 = Latest)
}

ConfirmVbox() {
  while :
  do
    print_heading
    PrintOne "It appears that feliz is running in Virtualbox."
    PrintOne "If it is, feliz can install Virtualbox guest"
    PrintOne "utilities and make appropriate settings for you."
    Echo
    PrintOne "Install Virtualbox guest utilities?: "
    Echo
    DisplayButtons "Yes/No" "[ Yes ] [ No ]" "Use arrow keys to move. [Enter] to select"
    Echo
    case $Response in
      1) IsInVbox="VirtualBox"
      ;;
      "") invalid_option
        continue
      ;;
      *) IsInVbox=""
    esac
    return 0
  done
}

getkeymap() {
  print_heading
  Echo
  PrintOne "Let's try to find your keyboard"
  while :
  do
    PrintOne "If you know the code for your keyboard layout, please enter"
    PrintOne "it now. If not, try entering a two-letter abbreviation for"
    PrintOne "your country or language and a list will be displayed. If"
    PrintOne "your keyboard is not listed, select [ Exit ] to try again."
    Echo
    TPread "(eg: 'atari' or 'us'): "
    local Term="${Response,,}"
    Echo
    ListKbs=$(cat keymaps.list | grep ${Term})
    if [ -n "${ListKbs}" ]; then  # If a match or matches found
      print_heading
      listgen1 "$ListKbs" "" ""
      if [ ${Result} = "Exit" ]; then
        print_heading
        Echo
        continue
      else
        Countrykbd="${Result}"
      fi
      loadkeys ${Countrykbd} 2>> feliz.log
      break
    else
      print_heading
      Echo
      PrintOne "No keyboards found containing '$Term'"
      PrintOne "Please try again"
      continue
    fi
  done
  print_heading
  read_timed "The keyboard is now set to: '$Countrykbd'" 1
}

setlocale() {
  SearchPrompt=" (for example: GB or PT): "
  print_heading
  PrintOne "Next we will try to find your locale. This will"
  PrintOne "be used to set fonts and language, and to find"
  PrintOne "the best mirrors for downloading your system"
  while :
  do
    Echo
    PrintOne "Please enter a two-letter code for your country."
    Echo
    TPread "$SearchPrompt"
    if [ -z ${Response} ]
    then
      invalid_option
    else
      Echo
      Response="${Response:0:2}"              # Make sure only two characters
      SEARCHTERM="${Response^^}"              # Set to all uppercase
      LocaleList=$(grep ${SEARCHTERM}.UTF-8 /etc/locale.gen | grep -v "@" | sed 's/\..*$//' | sed 's/#//g' | awk '{print $1}' | sort | uniq)
      local Counter=0
      localelist=""
      for l in ${LocaleList[@]}
      do
        localelist="${localelist} $l"
        Counter=$((Counter+1))
      done
      if [ $Counter -eq 0 ]; then
        not_found
        continue
      fi
      Counted=$(echo $localelist | wc -w)
      Newlist=""
      for (( i=1; i <= Counted; ++i ))
      do
        loc=$(echo $localelist | awk "{print \$$i}")
        Newlist="$Newlist ${loc:0:2}"
      done
      localelist="${Newlist}"
      print_heading
      Echo
      PrintOne "Now please choose your language from this list,"
      PrintOne "or [ Exit ] to try again."
      listgen1 "${localelist}" "" ""
      case $Result in
      "Exit") Echo
      ;;
      *) CountryLocale="${Result}_${SEARCHTERM}.UTF-8"
        CountryCode=${Result:3:2}                     # 2 characters from position 3 in $Result
        break
      esac
    fi
    print_heading
  done
  print_heading
  read_timed "Locale is set to: ${CountryLocale:0:5}" 1 # 5 characters from position 0 in $CountryLocale
}

SetTimeZone() {
  while :
  do
    print_heading
    PrintOne "To set the system clock, please first"
    PrintOne "choose the World Zone of your location."
    Zones=$(timedatectl list-timezones | sed 's/\/.*$//' | uniq)
    Echo
    zones=""
    for x in ${Zones[@]}
    do
      zones="$zones $x"
    done
    listgen1 "${zones}" "" "nocancel"
    ZONE=$Result
    Echo
    case $Result in
      "UTC") SUBZONE=""
          print_heading
          read_timed "Zone set to: '$ZONE'" 1
          return 0
      ;;
      "Exit") continue
      ;;
      *) SetSubZone
        if [ $Return = "Exit" ]; then
          continue
        else
          print_heading
          read_timed "Zone and Subzone set to: '$ZONE/$SUBZONE'" 1
          return 0
        fi
    esac
  done
}

SetSubZone() {
  SubZones=$(timedatectl list-timezones | grep ${ZONE} | sed 's/^.*\///')
  while :
  do
    print_heading
    PrintOne "World Zone = $ZONE"
    Echo
    PrintOne "We can search on the first letter of your nearest"
    PrintOne "major city. To change World Zone, leave empty."
    Echo
    TPread "Please enter one letter: "
    Echo
    if [ -z ${Response} ]
    then
      SetTimeZone
    else
      Response="${Response:0:1}"  # In case user enters more than one letter
      Zone2="${Response^^}"     # Convert the first letter to upper case
    fi
    subzones=""
    local Counter=0
    for x in ${SubZones[@]}
    do
      if [ ${x:0:1} = ${Zone2} ]; then    # 1 character at position 0 in string $x
        subzones="$subzones $x"
        Counter=$((Counter+1))
      fi
    done
    if [ ${Counter} -eq 0 ]; then
      invalid_option
      continue
    fi
    print_heading
    PrintOne "Now choose your city from this list"
    PrintOne "... or [ Exit ] to try again if it is not there"
    Echo
    listgen1 "$subzones" "" ""
    case $Result in
      "Exit") SUBZONE=""
      ;;
      *) SUBZONE=$Result
    esac
    break
  done
}

UserName() {
  print_heading
  PrintOne "Enter a name for the primary user of the new system."
  PrintOne "If you don't create a username here, a default user"
  PrintOne "called 'archie' will be set up"
  Echo
  TPread "User Name: "
  Entered=${Response,,}
  case $Entered in
    "") UserName="archie"
    ;;
    *) UserName=${Entered}
  esac
  PrintOne "User '${UserName}' will be created."
}

SetHostname() {
  Entered="arch-linux"
  print_heading
  PrintOne "A hostname is needed. This will be a unique name to identify"
  PrintOne "your device on a network. If you do not enter one, the"
  PrintOne "default hostname of 'arch-linux' will be used."
  Echo
  TPread "Enter a hostname for your computer: "
  Entered=${Response,,}
  case $Entered in
    "") HostName="arch-linux"
    ;;
    *) HostName=${Entered}
  esac
  PrintOne "Hostname = $HostName"
}

PickLuxuries() { # User selects any combination from a store of extras
  CategoriesList="Accessories Desktop_Environments Graphical Internet Multimedia Office Programming Window_Managers"
  print_heading
  case "$LuxuriesList" in
  "") PrintOne "Now you have the option to add extras, such as a web browser,"
    PrintOne "desktop environment, etc, from the following categories."
    PrintOne "If you want only a base Arch installation, exit without choosing any extras."
  ;;
  *) PrintOne "You can add more items, or select items to delete."
  esac
  Echo
  while :
  do
    listgen1 "${CategoriesList}" "" ""
    Category=$Response
    if [ $Result = "Exit" ]; then
      break
    else
      ShoppingList
      print_heading
      PrintOne "Added so far:: ${LuxuriesList}"
      PrintOne "You can now choose from any of the other lists,"
      PrintOne "or choose [ Exit ] to finish this part of the setup."
    fi
  done
  if [ -n "${LuxuriesList}" ]; then
    Scope="Full"
  else
    Scope="Basic"
  fi
}

KeepOrDelete() {
  Bagged="$1"
  while :
  do
    print_heading
    Message="$Bagged is already in your shopping list."
    DisplayButtons "Yes/No" "[ Keep ] [ Delete ]" "Use arrow keys to move. [Enter] to select"
    case $Response in
      1) Temp="$LuxuriesList"
        break
      ;;
      2) Validated="Y"
        Temp=""
        for lux in $LuxuriesList
        do
          if [ ${lux} != ${Bagged} ]; then
            Temp="$Temp $lux"
          fi
        done
        break
      ;;
      *) invalid_option
    esac
  done
  LuxuriesList="$Temp"
}

ShoppingList() { # Called by PickLuxuries after a category has been chosen.
  Passed="Choose your first item"
  while :
  do
    print_heading
    PrintOne "Added so far: ${LuxuriesList}"
    Echo
    PrintOne "${Categories[$Category]}" # $Category is number of item in CategoriesList
    # Pass category to listgen2 for user to choose one item;
    local Counter=1
    case $Category in
       1) for i in ${Accessories}
          do
           LongAccs1[${Counter}]="$i - ${LongAccs[${Counter}]}"
           (( Counter+=1 ))
          done
         listgen2 "$Accessories" "" "" "LongAccs1"
       ;;
       2) for i in ${Desktops}
          do
           LongDesk1[${Counter}]="$i - ${LongDesk[${Counter}]}"
           (( Counter+=1 ))
          done
         listgen2 "$Desktops" "" "" "LongDesk1"
       ;;
       3) for i in ${Graphical}
          do
            LongGraph1[${Counter}]="$i - ${LongGraph[${Counter}]}"
           (( Counter+=1 ))
          done
           listgen2 "$Graphical" "" "" "LongGraph1"
       ;;
       4) for i in ${Internet}
          do
           LongNet1[${Counter}]="$i - ${LongNet[${Counter}]}"
            (( Counter+=1 ))
         done
         listgen2 "$Internet" "${Headline}" "" "LongNet1"
       ;;
       5) for i in ${Multimedia}
          do
            LongMulti1[${Counter}]="$i - ${LongMulti[${Counter}]}"
            (( Counter+=1 ))
          done
          listgen2 "$Multimedia" "" "" "LongMulti1"
       ;;
       6) for i in ${Office}
          do
            LongOffice1[${Counter}]="$i - ${LongOffice[${Counter}]}"
            (( Counter+=1 ))
          done
          listgen2 "$Office" "" "" "LongOffice1"
       ;;
       7) for i in ${Programming}
          do
            LongProg1[${Counter}]="$i - ${LongProg[${Counter}]}"
            (( Counter+=1 ))
          done
          listgen2 "$Programming" "" "" "LongProg1"
       ;;
       8) for i in ${WindowManagers}
          do
            LongWMs1[${Counter}]="$i - ${LongWMs[${Counter}]}"
            (( Counter+=1 ))
          done
          listgen2 "$WindowManagers" "" "" "LongWMs1"
      ;;
      *) break
    esac
    Passed="Choose your next item" # Loop until user selects "Exit"
    if [ $Result = "Exit" ]; then
      break
    fi
    AddToList="Y"
    # First check that chosen item is not already on the list
    for lux in $LuxuriesList
    do
      if [ ${lux} = ${Result} ]; then
        KeepOrDelete "$Result" # New function
        Result=""
        continue
      fi
    done
    # Then carry out any specific tests and add the item to the list
    SaveResult=$Result # (Because other subroutines return $Result)
    case $SaveResult in
      "Budgie" | "Cinnamon" | "Deepin" | "Enlightenment" | "Fluxbox" | "Gnome" | "KDE" | "LXDE" | "LXQt" |  "Mate" | "Openbox" | "Xfce") DesktopEnvironment=$SaveResult

       ;;
      "") continue
       ;;
      *) Echo
    esac
    if [ ${SaveResult} = "libreoffice" ]; then
      LuxuriesList="${LuxuriesList} libreoffice-fresh"
    else
      LuxuriesList="${LuxuriesList} ${SaveResult}"
    fi
  done
  Passed=""     # Clear the information variable
}

ChooseDM() { # Choose a display manager
  case $DisplayManager in
  "") # Only offered if no other display manager has been set
      Counter=0
      Greeter=""
      DMList="GDM LightDM LXDM sddm SLIM XDM"
      print_heading
      PrintOne "A display manager provides a graphical login screen."
      PrintOne "If in doubt, choose LightDM."
      PrintOne "If you do not install a display manager, you will have"
      PrintOne "to launch your desktop environment manually."
      Echo
      listgen1 "${DMList}" "" ""
      Reply=$Response
      for item in ${DMList}
      do
        Counter=$((Counter+1))
        if [ $Counter -eq $Reply ]
        then
          SelectedDM=$item
          case $SelectedDM in
            "GDM") DisplayManager="gdm"
              ;;
            "LightDM") DisplayManager="lightdm"
                  Greeter="lightdm-gtk-greeter"
              ;;
            "LXDM") DisplayManager="lxdm"
              ;;
            "sddm") DisplayManager="sddm"
              ;;
            "SLIM") DisplayManager="slim"
              ;;
            "XDM") DisplayManager="xdm"
              ;;
            *) DisplayManager=""
          esac
          break
        fi
      done
    ;;
  *) # Warn that DM already set, and offer option to change it
      print_heading
      PrintOne "Display manager is already set as: $DisplayManager."
      PrintOne "Only one display manager can be active"
      Echo
      PrintOne "Do you wish to change it?: "
      Echo
      DisplayButtons "Yes/No" "[ Yes ] [ No ]" "Use arrow keys to move. [Enter] to select"
      Echo
      if [ $Response -eq 1 ]; then    # User wishes to change DM
        DisplayManager=""             # Clear DM variable
        Greeter=""                    # and greeter
        ChooseDM                      # Call this function again
      fi
  esac
}

SetGrubDevice() {
  DEVICE=""
  DevicesList="$(lsblk -d | awk '{print "/dev/" $1}' | grep 'sd\|hd\|vd')";
  print_heading
  GrubDevice=""
  local Counter=0
  PrintOne "Select the device where Grub is to be installed."
  PrintOne "Note that if you do not select a device, Grub"
  PrintOne "will not be installed, and you will have to make"
  PrintOne "alternative arrangements for booting your new system."
  Echo
  listgen1 "${DevicesList}" "" ""
  Reply=$Response
  for i in ${DevicesList}
  do
    Item=$i
    Counter=$((Counter+1))
    if [ $Counter -eq $Reply ]; then
      GrubDevice=$Item
      break
    fi
  done
}

FinalCheck() {
  while :
  do
    print_heading
    PrintOne "These are the settings you have entered. Please check them ..."
    Echo
    if [ ${UEFI} -eq 1 ]; then
      PrintOne "0)  Boot partition ... $EFIPartition             "
      PrintMany "1)  Root partition ... $RootPartition : $RootType"
    else
      PrintOne "1)  Root partition ... $RootPartition : $RootType"
    fi
    if [ $SwapPartition ] || [ $SwapFile ]; then
      PrintMany "2)  Swap partition ... $SwapPartition $SwapFile"
    else
      PrintMany "2)  No provision has been made for swap"
    fi
    if [ ${#AddPartList[@]} -gt 0 ]; then
      Counter=0
      PrintMany "3)  Extra partitions ..."
      for i in ${AddPartList[@]}
      do
        PrintMany "     ${AddPartMount[$Counter]} : ${AddPartList[$Counter]} : ${AddPartType[$Counter]}"
        Counter=$((Counter+1))
      done
    else
      PrintMany "3)  No additional partitions have been allocated"
    fi
    case $Kernel in
      1) PrintMany "4)  The LTS kernel will be installed"
      ;;
      *) PrintMany "4)  The latest kernel will be installed"
    esac
    if [ $GrubDevice ]; then
    PrintMany "5)  Grub will be installed to $GrubDevice"
    else
      PrintMany "5)  No provision has been made for Grub"
    fi
    PrintMany "6)  Keyboard is $Countrykbd"
    PrintMany "7)  Locale will be set to $CountryLocale"
    PrintMany "8)  Zone/subZone will be $ZONE/$SUBZONE"
    case ${IsInVbox} in
      "VirtualBox") PrintMany "9)  Virtualbox guest utilities will be installed"
      ;;
      *) PrintMany "9)  Virtualbox guest utilities will not be installed"
    esac
    if [ -z $DisplayManager ]; then
      PrintMany "10)  No Display Manager selected"
    else
      PrintMany "10)  Display Manager = $DisplayManager"
    fi
    PrintMany "11)  Root and user settings ..."
    PrintMany "     Hostname = '$HostName'"
    PrintMany "     User = '$UserName'"
    PrintMany "12) The following extras have been selected ..."
    PrintOne "${LuxuriesList}"
    Echo
    PrintOne "Press [Enter] to install with these settings, or"
    Response=20
    TPread "enter an item number if you wish to change it: "
    Change=$Response
    case $Change in
      1) ChangeRootPartition
        AllocateRoot
        continue
      ;;
      2) ChangeSwapPartition
        AllocateSwap
        continue
      ;;
      3) ChangePartitions
        MorePartitions
        continue
      ;;
      4) SetKernel
        continue
      ;;
      5) SetGrubDevice
        continue
      ;;
      6) getkeymap
        continue
      ;;
      7) setlocale
        continue
      ;;
      8) SetTimeZone
        continue
      ;;
      9) ConfirmVbox
        continue
      ;;
      10) DisplayManager=""
        ChooseDM
        continue
      ;;
      11) ManualSettings
        continue
      ;;
      12) PickLuxuries
        continue
      ;;
      *) break
    esac
  done
}

ManualSettings() {
  while :
  do
    print_heading
    PrintOne "Enter number for data to change, or [Enter] to finish:"
    Echo
    PrintOne "1) Hostname (currently $HostName)"
    PrintMany "2) Username (currently $UserName)"
    Echo
    TPread "Enter the number of your selection : "
    Echo
    case $Response in
      1) TPread "Enter new Hostname (currently $HostName) : "
         HostName=$Response
        ;;
      2) TPread "Enter new username to be created (currently $UserName) : "
         UserName=$Response
        ;;
      *) return 0
    esac
  done
}

ChangeRootPartition() {
# Start array with SwapPartition
  Ignorelist[0]=${SwapPartition}
  local Counter=1
  AddExtras
  MakePartitionList
}

ChangeSwapPartition() {
# Start array with RootPartition
  Ignorelist[0]=${RootPartition}
  Counter=1
  AddExtras
  MakePartitionList
}

ChangePartitions() {
  # Copy RootPartition and SwapPartition into temporary array
  Ignorelist[0]=${RootPartition}
  local Counter=1
  if [ ${SwapPartition} ]; then
    Ignorelist[1]=${SwapPartition}
    Counter=2
  fi
  Ignores=${#Ignorelist[@]} # Save a count for later
  MakePartitionList
}

AddExtras() {
  # Ignorelist started and Counter set to next record number by calling
  # function ChangeSwapPartition or ChangeRootPartition
  # Add each field (extra partition) from AddPartList into the array:
  for a in ${AddPartList[@]}; do
    Ignorelist[$Counter]=$a
    Counter=$((Counter+1))
  done
  Ignores=${#Ignorelist[@]} # Save a count for later
}

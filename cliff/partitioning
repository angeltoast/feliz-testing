#!/bin/bash

# felizparts - Partitioning functions

# Developed by Elizabeth Mills, incorporating some code adapted from
# the excellent Evo/Lution script by Carl Duff and AUI scripts by HelmuthDU.

# Please read the introduction in the README file

# -----------------------      ------------------------
# Functions         Line       Functions           Line
# -----------------------      ------------------------
# CheckParts          24       BuildPartitionLists 298
# Partitioning        94       UpdateArray         322
# Parted             124       AllocateRoot        384
# AutoPartition      128       CheckPartition      440
# AutoWarning        171       AllocateSwap        494
# select_filesystem  188       SetSwapFile         504
# SetLabel           259       MorePartitions      588
# EditLabel          276       MakePartition       612
# -----------------------      ------------------------

CheckParts() {
# First test for existing partitions
  ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
  local Counter=0
  for i in $ShowPartitions
  do
    Counter=$((Counter+1))
  done
  PARTITIONS=${Counter}
  # If no partitions exist, offer cfdisk to create (or exit)
  if [ $PARTITIONS -eq 0 ]
  then
    print_heading
    while [ $PARTITIONS -eq 0 ]
    do
      echo
      PrintOne "${_No_Parts_Text1}"
      PrintOne "${_No_Parts_Text2}"
      PrintOne "${_No_Parts_Text3}"
      echo
      PrintOne "${_No_Parts_Text4}"
      PrintOne "${_No_Parts_Text5}"
      PrintOne "${_Do_Nothing}"
      PrintOne "${_No_Parts_Text7}"
      echo
      Partitioning # Partitioning options
      if [ $Response = "3" ]; then
        read_timed "${_Exiting}"
        exit
      fi
      # Check that partitions have been created
      ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
      Counter=0
      for i in $ShowPartitions
      do
        Counter=$((Counter+1))
      done
      PARTITIONS=${Counter}
    done
    # Call function to generate an array of partitions
    BuildPartitionLists # This is a first call
  else
    # Alternatively, offer cfdisk to edit existing partitions
    print_heading
    PrintOne "${_CheckParts_Available} ..."
    echo
    # Call function to generate an array of partitions
    BuildPartitionLists # This is a first call
    Counter=0
    for part in ${PartitionList}
    do
      if [ $Counter = 0 ]; then
        PrintOne "${PartitionArray[$Counter]}"
      else
        PrintMany "${PartitionArray[$Counter]}"
      fi
      Counter=$((Counter+1))
    done
    echo
    PrintOne "${_CheckParts_Options1}"
    PrintOne "${_CheckParts_Options2}"
    PrintOne "${_Do_Nothing}"
    PrintOne "${_CheckParts_Options4}"
    echo
    Partitioning # Partitioning options
    # Call function to regenerate the array of partitions
    MakePartitionList
  fi
}

Partitioning() {
  local Proceed=""
  AutoPart=0 # Set flag to 'off' by default
  while [ -z $Proceed ]
  do
    PrintOne "1) ${_CheckParts_Menu1}"
    PrintMany "2) ${_CheckParts_Menu2}"
    PrintMany "3) ${_CheckParts_Menu3}"
    echo
    TPread "${_Number_of_selection} : "
    Proceed=$Response
    echo
    case $Proceed in
      1) cfdisk &>> feliz.log
        tput setf 0 # Change foreground colour to black temporarily to hide error message
        partprobe &>> feliz.log #Inform kernel of changes to partitions
        tput sgr0 # Reset colour
        ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
      ;;
      2) AutoPartition
      ;;
      3) echo
      ;;
      *) invalid_option
        Proceed=""
        print_heading
    esac
  done
}

Parted() {
  parted --script /dev/${UseDisk} "$1" &>> feliz.log
}

AutoPartition() {
# Called from option 2) within Partitioning()
AutoPart=0
until [ ${AutoPart} -gt 0 ]
do
  DiskDetails=`lsblk -l | grep 'disk' | awk '{print $1}'`
  UseDisk=$DiskDetails # If more than one, UseDisk will be first
  # Count lines. If more than one disk, ask user which to use
  local Counter=0
  CountDisks=0
  for i in $DiskDetails
  do
    Counter=$((Counter+1))
    Drives[$Counter]=$i
  done
  if [ $Counter -gt 1 ]
  then
    UseDisk="" # Reset for user choice
    while [ -z $UseDisk ]
    do
      print_heading
      PrintOne "${_Available_devices0} $Counter ${_Available_devices1}"
      PrintOne "${_Available_devices2}"
      PrintOne "${_Available_devices3}"
      PrintOne "${_Available_devices4}"
      echo
      Counter=0
      for i in $DiskDetails
      do
        Counter=$((Counter+1))
        PrintOne "$Counter) $i"
      done
      echo
      TPread "${_Number_of_selection}: "
      UseDisk="${Drives[$Response]}"
      AutoWarning
    done
  else
    AutoWarning
  fi
done
}

AutoWarning() {
while :
do
  print_heading
  PrintOne "${_AutoWarning1} ${UseDisk}"
  Message="${_AutoWarning2}: "
  listgen1 "${_Yes} ${_No}" "${_Autopartition}" "nodone"
  case $Response in
    1) RunAutoPart
      print_heading
      PrintOne "${_AutoWarning_Message0} ${GrubDevice} ${_successful}"
      PrintOne "-------------------------------------"
      PrintMany "${_Swap}: ${SwapPartition}${SwapFile} $ShowPart1"
      PrintMany "${_Root}: ${RootPartition} ${RootType} $ShowPart2"
      if [ ${Home} = "Y" ]; then
        ShowPart3=`lsblk -l | grep "${UseDisk}3" | awk '{print $4}'` >/dev/null
        PrintMany "${_Home}: ${AddPartList[0]} ${AddPartType[0]} $ShowPart3"
      fi
      echo
      PrintOne "${_AutoWarning_Message1}"
      echo
      PrintOne "${_Press_Any_Key}"
      read -n1
      break
      ;;
    2) UseDisk=""
      break 2
      ;;
    *) invalid_option
  esac
done
}


select_filesystem() { # $1 = list passed as string by caller
  local Counter=0
  PrintOne "${_select_filesystem1} ${Partition}"
  PrintOne "${_select_filesystem2}"
  echo
  listgen1 "${TypeList}" "Filesystems"
  for i in ${TypeList}
  do
    Counter=$((Counter+1))
    if [ $Counter -eq $Response ]
    then
      PartitionType=$i
      break
    fi
  done
}

SetLabel() { # Called from the root, swap and extra partitions routines
# ... each passing a single argument containing the partition ID
# Build an associative array of partitions (LabellingArray[]) as
# declared in felizrunning with other arrays
PartitionID=$1
local HowMany="${#PartitionArray[@]}"
local x=0
until [ ${x} -eq ${HowMany} ]
do
  CompareID=`echo ${PartitionArray[${x}]} | awk '{print $1}'`
  if [ -z ${CompareID} ]; then
    x=$((x+1))
    continue
  fi
  if [ ${CompareID} = ${PartitionID} ]; then # If the partition is in the array, it has a label
  #  Label=`echo ${PartitionArray[${x}]} | awk '{print $4}'` # Save the label
  Label=`echo ${PartitionArray[${x}]}`
  fi
  x=$((x+1))
done
}

EditLabel() {
Label="${Labelled[$1]}"
if [ -n ${Label} ]; then
  # Inform the user and accept input
  print_heading
  echo
  PrintOne "${_EditLabel0} '${Label}'"
  echo
  PrintOne "${_EditLabel1}            "
  PrintMany "${_EditLabel2}"
  PrintMany "${_EditLabel3}"
  echo
  TPread "${_Enter} 1, 2 ${_EditLabel4}: "
  # Save to the -A array
  case $Response in
    1) LabellingArray[$PartitionID]=$Label
    ;;
    2) LabellingArray[$PartitionID]=""
    ;;
    *) LabellingArray[$PartitionID]=$Response
  esac
fi
}

BuildPartitionLists() {
  # 1) First get a list of all partitions up to sda99 | select first field | remove /dev/ | remove colon
  ListTypeIDs=`sudo blkid /dev/sd* | grep ' TYPE' | awk '{print $1}' | cut -c 6- | sed s/://g`
  # Then get matching list of types, removing unwanted text (TYPE=) and quotes
  ListTypes=`sudo blkid /dev/sd* | grep ' TYPE' | awk '{print $(NF-1)}' | cut -c 6- | sed s/\"//g`
  # Add records from those two indexed arrays into the associative array
  local Counter=0
  for i in ${ListTypeIDs}
  do
    x=0
    for l in ${ListTypes}
    do
      if [ $x -eq $Counter ]; then
        FileSystem[$i]=$l # ... get the matching type
      break
      fi
      x=$((x+1))
    done
    Counter=$((Counter+1))
  done
  # 2) Find all up to sd*99 with LABEL | select 1st field | remove /dev/ | remove colon
  ListLabelledIDs=`sudo blkid /dev/sd* | grep LABEL | awk '{print $1}' | cut -c 6- | sed s/://g`
  # If at least one labelled partition found, get a matching list of labels (remove quotes)
  if [ -n "$ListLabelledIDs" ]; then
    ListLabelledLabels=`sudo blkid /dev/sd* | grep LABEL | awk '{print $2}' | cut -c 7- | sed s/\"//g`
  fi
  # Add records from those two indexed arrays into associative array
  Counter=0
  for i in ${ListLabelledIDs}
  do
    x=0
    for l in ${ListLabelledLabels}
    do
      if [ $x -eq $Counter ]; then
        Labelled[$i]=$l # ... get the matching label
      break
      fi
      x=$((x+1))
    done
    Counter=$((Counter+1))
  done
  local HowManyLabelled="${#Labelled[@]}"
  # 3) Find any partitions flagged as bootable
  ListAll=`sudo sfdisk -l | grep /dev | grep '*' | awk '{print $1}' | cut -c 6-`
  declare -a Flagged
  Counter=0
  for i in $ListAll
  do
    Flagged[${Counter}]="$i"
    Counter=$((Counter+1))
  done
  local HowManyFlagged="${#Flagged[@]}"
  # 4) Prepare list of short identifiers (sda1 sda2 ...)
  PartitionList=""
  ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
  # 5) Run through short identifiers, checking the three arrays for a match
  Counter=0 # For count of partitions
  Label=""
  for part in ${ShowPartitions}
  do
  # First test Flagged
    local x=0
    until [ ${x} -eq ${HowManyFlagged} ]
    do
      if [ $part = "${Flagged[$x]}" ]; then
        Bootable="(Bootable)"
        break
      else
        Bootable=""
      fi
      x=$((x+1))
    done
    # Next test Labelled
    ThisPart=${Labelled[${part}]} # Find the record in Labelled that matches the current iteration
    if [ -n "${ThisPart}" ]; then
      Label="${ThisPart}"
    fi
    # Finally get the filesystem type
    ThisPart=${FileSystem[${part}]} # Find the record in FileSystem that matches the current iteration
    LongID=`lsblk -l | grep ${part} | awk '{print $1 " " $4 " " $7}'`
    PartitionArray[${Counter}]="$LongID $ThisPart ${Label} ${Bootable}"
    Label=""
    # Save the short ID for later functions
    PartitionList="${PartitionList} ${part}"
    Counter=$((Counter+1))
  done
  PARTITIONS=${Counter}
}

UpdateArray() { # Remove the selected partition from $PartitionArray[]
  local Counter=0
  # Empty NewArray
  local HowMany="${#NewArray[@]}"
  local x=0
  until [ ${x} -eq ${HowMany} ]
  do
    unset NewArray[$x]
    x=$((x+1))
  done
  # Build NewArray without partition selected in calling function
  for p in "${PartitionArray[@]}"
  do
    First=`echo $p | cut -c 1-5`
    if [ ${Result} != ${First} ]; then
      NewArray[${Counter}]="$p"
      Counter=$((Counter+1))
    fi
  done
  # Then copy NewArray into PartitionArray
  Counter=0
  for p in "${NewArray[@]}"
  do
    PartitionArray[${Counter}]=${NewArray[$Counter]}
    Counter=$((Counter+1))
  done
  unset PartitionArray[$Counter] # Delete the last element
}

AllocateRoot() {
  # Display partitions for user-selection
  # Uses list of all available partitions in PartitionList
  print_heading
  Remaining=""
  local Counter=0
  Partition=""
  PartitionType=""
  PrintOne "${_AllocateRoot0} ${_root}"
  echo
  listgen2 "$PartitionList" "Partitions" "" "PartitionArray"
  Reply=$Response
  if [ $Result != "${_Done}" ]; then
    PassPart=$Result
    SetLabel "$Result"
    UpdateArray # Remove the selected partition from $PartitionArray[]
  fi
  Counter=0
  for i in ${PartitionList}
  do
    Counter=$((Counter+1))
    if [ $Counter -eq $Reply ]; then
      Partition="/dev/$i"
      RootPartition="${Partition}"
      # Before going to select_filesystem, check the partition
      CheckPartition
      if [ ${CurrentType} ]; then
        PrintOne "${_AllocateRoot1}"
        PrintOne "${_AllocateRoot2}"
        PrintOne "${_AllocateRoot3}"
        echo
        TypeList="ext2 ext3 ext4 btrfs"
      else
        TypeList="ext2 ext3 ext4 btrfs"
      fi
      # Now select a filesystem
      select_filesystem
      if [ -z ${PartitionType} ]
      then
        RootType="ext4"
      else
        RootType="${PartitionType}"
      Label="${Labelled[${PassPart}]}"
      if [ -n "${Label}" ]; then
        EditLabel $PassPart
      fi
      fi
    else
      Remaining="$Remaining $i" # Add next available partition
    fi
  done
  PartitionList=$Remaining      # Replace original PartitionList with remaining options
}

CheckPartition() {
# Finds if there is an existing file system on the selected partition
print_heading
CurrentType=`file -sL ${Partition} | grep "ext" | cut -c26-30`
if [ ${CurrentType} ]; then
  PrintOne "${_CheckPartition0} ${Partition} ${_CheckPartition1} ${CurrentType}"
  PrintOne "${_CheckPartition2}"
fi
}

AllocateSwap() {
# Checks if remaining partitions and allows selection for swap
print_heading
if [ -n "${PartitionList}" ]
then
  PrintOne "${_AllocateSwap1}"
  PrintOne "${_AllocateSwap2}"
  PrintOne "${_AllocateSwap3}"
  echo
  Remaining=""
  local Counter=0
  SwapPartition=""
  PickFrom="$PartitionList Swapfile"
  SwapFile=""
  declare -a CopyArray # For passing to listgen2
  local Counter=0
  for p in "${PartitionArray[@]}"
  do
    CopyArray[${Counter}]=${PartitionArray[$Counter]}
    Counter=$((Counter+1))
  done
  CopyArray[${Counter}]="${_Swapfile}"
  PrintOne "${_AllocateSwap4}:"
  echo
  listgen2 "$PickFrom" "Partitions" "" "CopyArray"
  Reply=$Response # Number of selected item
  if [ $Result != "${_Swapfile}" ] && [ $Result != "${_Done}" ]; then # Short ID of selected item
    PassPart=$Result
  fi
  echo
  Counter=0
  for i in ${PickFrom}
  do
    Counter=$((Counter+1))
    if [ $Counter -eq $Reply ]
    then
      case $i in
        "${_Done}") SwapPartition=""
              break
        ;;
        "${_Swapfile}") SetSwapFile
            SwapPartition=""
            break
        ;;
        *) SwapPartition="/dev/$i"
         # IsSwap=`lsblk -l | grep $i | grep SWAP | awk '{print $7}'`
          IsSwap=`sudo blkid /dev/sd* | grep 'swap' | awk '{print $1}'`
          if [ -n "$IsSwap" ]; then
            PrintOne "$i ${_AllocateSwap5}"
            Message="${_<confirmation_message>}: "
            listgen1 "${_Yes} ${_No}" "${_AllocateSwap6}" "nodone"
            case $Response in
              1) MakeSwap="Y"
              ;;
              2) MakeSwap="N"
              ;;
              *) MakeSwap="Y"
            esac
          fi
          Label="${Labelled[${PassPart}]}"
          if [ -n "${Label}" ]; then
            EditLabel "$PassPart"
            SetLabel "$PassPart"
          fi
          UpdateArray # Remove the selected partition from $PartitionArray[]
      esac
    else
      if [ $i != "${_Done}" ] && [ $i != Swapfile ]; then
        Remaining="$Remaining $i" # Add next available partition
      fi
    fi
  done
  echo
  if [ $SwapPartition ]; then
    read_timed "$SwapPartition ${_AllocateSwap7}" 1
  elif [ $SwapFile ]; then
    read_timed "${_AllocateSwap8} ${SwapFile} ${_AllocateSwap9}" 1
  else
    read_timed "${_AllocateSwap0}" 1
  fi
  echo
  PartitionList=$Remaining  # Replace original PartitionList with remaining options
fi
}

SetSwapFile() {
LoopRepeat="Y"
while [ ${LoopRepeat} = "Y" ]
do
  PrintOne "${_SetSwapFile1}"
  TPread "${_SetSwapFile2}: "
  RESPONSE="${Response^^}"
  # Check that entry includes 'M or G'
  CheckInput=(`echo $RESPONSE | grep "G\|M"`)
  echo
  if [ -z ${CheckInput} ]; then
    PrintOne "${_SetSwapFile3}"
    SwapFile=""
  else
    SwapFile=$RESPONSE
    LoopRepeat="N"
  fi
  if [ ${LoopRepeat} = "N" ]
  then
    break
  fi
done
}

MorePartitions() {
  local Elements=0
  AddedToRemaining=0
  for i in ${PartitionList}
  do
    Elements=$((Elements+1))
  done
  while [ $Elements -gt 0 ]
  do
    print_heading
    Remaining=""
    PrintOne "${_MorePartitions1}"
    PrintOne "${_MorePartitions2}"
    PrintOne "${_MorePartitions3}"
    echo
    listgen2 "$PartitionList" "Partitions" "" "PartitionArray"
    if [ $Result != "${_Done}" ]; then
      PassPart=$Result
      SetLabel "$Result"
      UpdateArray # Remove the selected partition from $PartitionArray[]
    fi
    echo
    for Part in ${PartitionList} # Iterate through the list
    do
      Partition=""
      PartitionType=""
      if [ $Part = $Result ] && [ $Result != "${_Done}" ]; then
        Partition="/dev/$Part"
        MakePartition # Call complete details
        Label="${Labelled[${PassPart}]}"
        if [ -n "${Label}" ]; then
          EditLabel $PassPart
        fi
      elif [ $Part != "${_Done}" ]; then   # Part is not selected and not 'Done'
        Remaining="$Remaining $Part" # Add unused partition to temp list
        AddedToRemaining=$(($AddedToRemaining+1))
      fi
    done
    PartitionList=$Remaining  # Replace original PartitionList with temp list
    if [ $Result = "${_Done}" ]; then
      Elements=0
      break
    else
      Elements=$AddedToRemaining
    fi
  done
  # Ensure that if AddPartList (the defining array) is empty, all others are too
  if [ -z ${#AddPartList[@]} ]
  then
    AddPartList=""
    AddPartMount=""
    AddPartType=""
  fi
}

MakePartition() { # Called by MorePartitions
  # Add the selected partition to the array for extra partitions
  # 1) Save to AddPartList (eg: /dev/sda5)
  ExtraPartitions=${#AddPartList[@]}
  AddPartList[$ExtraPartitions]="${Partition}"
  CheckPartition   # Before going to select_filesystem, check the partition
  if [ ${CurrentType} ]; then
    PrintOne "${_MakePartition1}"
    PrintOne "${_MakePartition2}"
    echo
  fi
  # 2) Select filesystem
  TypeList="ext2 ext3 ext4 btrfs" # Set format types for the selected partition
  select_filesystem
  AddPartType[$ExtraPartitions]="${PartitionType}"  # Add it to AddPartType list
  # 3) Get a mountpoint
  LoopRepeat="Y"
  while [ ${LoopRepeat} = "Y" ]
  do
    echo
    PrintOne "${_MakePartition3} ${Partition} ..."
    TPread "${_MakePartition4} ... /"
    # Check that entry includes '/'
    CheckInput=(`echo $Response | cut -c1`)
    case ${CheckInput} in
      "") PrintOne "${_MakePartition5}"
          PartMount=""
          ;;
      *) if [ ${CheckInput} != "/" ]; then
            PartMount="/${Response}"
        else
            PartMount="${Response}"
        fi
    esac
    # Check that the mountpoint has not already been used
    MountPointCounter=0
    if [ -z ${AddPartMount} ]; then
      LoopRepeat="N"
    else
      # Go through AddPartMount checking each item against PartMount
      for MountPoint in ${AddPartMount}
      do
        MountPointCounter=$((MountPointCounter+1))
        if [ $MountPoint = $PartMount ]; then
          read_timed "${_Mountpoint} ${PartMount} ${_MakePartition6}"
        else
          LoopRepeat="N"
          break
        fi
      done
    fi
    if [ ${LoopRepeat} = "N" ]
    then
      break
    fi
  done
  AddPartMount[$ExtraPartitions]="${PartMount}"
}

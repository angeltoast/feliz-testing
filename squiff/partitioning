#!/bin/bash

# partitioning - Partitioning functions - Dialog version

# Developed by Elizabeth Mills, incorporating some code adapted from
# the excellent Lution scripts by Carl Duff and AUI scripts by HelmuthDU

# Please read the introduction in the README file

# -----------------------      ------------------------
# Functions         Line       Functions           Line
# -----------------------      ------------------------
# CheckParts          24       BuildPartitionLists 293
# Partitioning        75       UpdateArray         382
# Parted              99       AllocateRoot        404
# AutoPartition      103       CheckPartition      460
# AutoWarning        152       AllocateSwap        476
# RunAutoPart        167       SetSwapFile         520
# FileSystem         232       MorePartitions      560
# SetLabel           247       MakePartition       614
# EditLabel          269
# -----------------------      ------------------------

CheckParts() { # First check of available partitions on the system
Backtitle="If you need guidance, consult the Arch Wiki Beginners' Guide"
Passed=$Backtitle
# First test for existing partitions
	ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
  local Partitions=0
  for i in $ShowPartitions
  do
    (( Partitions+=1 ))
    break
  done
	# If no partitions exist, offer cfdisk to create (or exit)
  if [ $Partitions -eq 0 ]
  then
    while [ $Partitions -eq 0 ]
    do
      local Message="There are no partitions on the device, and at least one partition is needed for the root directory. If you choose <Do nothing> the script will terminate to allow you to partition in some other way."
      Partitioning # Partitioning options
      if [ $Proceed -eq 3 ]; then
        PrintOne "Exiting feliz! Hurry back, y'hear?"
        exit
      fi
      # Check that partitions have been created
      ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
      Partitions=0
      for i in $ShowPartitions
      do
        (( Partitions+=1 ))
        break
      done
    done
    # Call function to generate an array of partitions
		BuildPartitionLists # This is a first call
  else
    # Generate an array of partitions
		BuildPartitionLists # This is a first call
    Partitions=0
    # Copy array to variable for display
    ExistingPartitions=""
    for part in ${PartitionList}
    do
      ExistingPartitions="$ExistingPartitions ${PartitionArray[$Partitions]}\n"
      (( Partitions+=1 ))
    done
    local Message="Here is a list of available partitions on all connected devices ...\n$ExistingPartitions\nIf you choose <Do nothing> the script will enable you to allocate the existing partitions."
    Partitioning # Partitioning options
    # Call function to regenerate the array of partitions
    MakePartitionList
	fi
}

MakePartitionList() { # This function was missing from all parts of Feliz
  # It has been recovered from Achoo, to see if this is the cause of 
  # problems with displaying partitions. If successful in squiff, it should be added to cliff.
  
  # Call BuildPartitionLists function to generate an array of partitions
  # This is not a first call, so first empty the existing array
 	local x=0
  local HowMany="${#PartitionArray[@]}"
  until [ ${x} -eq ${HowMany} ]
  do
    unset PartitionArray[$x]
    x=$((x+1))
  done
  BuildPartitionLists # Then rebuild
}

Partitioning() {
  Proceed=""
  AutoPart=0 # Set flag to 'off' by default
  while [ -z $Proceed ]
  do
    dialog --backtitle "$Backtitle" --title " Partitioning " --cancel-label "Do nothing"\
      --menu "$Message" 20 55 2 \
        "1" "Open cfdisk so I can partition manually" \
        "2" "Allow feliz to partition the whole device" 2> output.file
    Proceed=$(cat output.file)
    case $Proceed in
      1) cfdisk 2>> feliz.log
        tput setf 0 # Change foreground colour to black temporarily to hide error message
        partprobe 2>> feliz.log #Inform kernel of changes to partitions
        tput sgr0 # Reset colour
        ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
      ;;
      2) AutoPartition
      ;;
      *) Proceed=3
     esac
  done
}

Parted() {
  parted --script /dev/${UseDisk} "$1" 2>> feliz.log
}

AutoPartition() {
# Called from option 2) within Partitioning()
AutoPart=0
until [ ${AutoPart} -gt 0 ]
do
  DiskDetails=`lsblk -l | grep 'disk' | awk '{print $1}'`
  UseDisk=$DiskDetails # If more than one, UseDisk will be first
  # Count lines. If more than one disk, ask user which to use
  local Counter=0
  for i in $DiskDetails
  do
    (( Counter+=1 ))
    Drives[$Counter]=$i
  done
  if [ $Counter -gt 1 ]
  then
    UseDisk="" # Reset for user choice
    Counter=0
    ExistingPartitions="" # Prepare variable
    for i in $DiskDetails
    do
      (( Counter+=1 ))    
      ExistingPartitions="$ExistingPartitions $i\n"
    done
    while [ -z $UseDisk ]
    do
      local Message="There are $Counter devices available\n$ExistingPartitions\nWhich do you wish to use for installation?\n(Remember, this is auto-partition, and any data on the chosen device will be lost)"
      dialog --backtitle "$Backtitle" --title " auto-partition " \
      --inputbox "\n$Message\n" 18 50 2> output.file
      UseDisk=$(cat output.file)
      #  Check entry against list
      for i in $DiskDetails
      do
        if [ $i = $UseDisk ]; then
          Counter=1
        fi
      done 
      if [ $Counter -ne 1 ]; then
        UseDisk=""
      fi  
      AutoWarning
    done
  else
    AutoWarning
  fi
done
}

AutoWarning() {
while :
do
  dialog --backtitle "$Backtitle" --title " auto-partition " \
    --yesno "\nThis will erase any data on '${UseDisk}'\nAre you sure you wish to continue?\n" 10 40
  case $? in
    0) RunAutoPart
      break
      ;;
    *) UseDisk=""
      break
  esac
done  
}

RunAutoPart() {
  GrubDevice="/dev/${UseDisk}"
  Home="N"
	# Get disk size
  DiskSize=`lsblk -l | grep "${UseDisk}\ " | awk '{print $4}' | sed s/G//g`
  # Create partitions and set variables for mounting
  Parted "mklabel msdos"
  if [ $DiskSize -gt 24 ]; then
    # Device is large enough for a separate /home partition
    # Swap 4GiB 
    Parted "mkpart primary linux-swap 1MiB 4GiB"
    SwapPartition="${GrubDevice}1"
    MakeSwap="Y"
    # Root partition 10GiB
    Parted "mkpart primary ext4 4GiB 14GiB"
    Parted "set 2 boot on"
    RootPartition="${GrubDevice}2"
    RootType="ext4"
    # Home partition = remainder (size from 10GiB to maximum available)
    Parted "mkpart primary ext4 14GiB 100%"
    AddPartList[0]="${GrubDevice}3" # Add to the array of additional partitions
    AddPartMount[0]="/home"
    AddPartType[0]="ext4"
    Home="Y"
  elif [ $DiskSize -gt 18 ]; then
    # Swap 4Gib and one main partition up to 20GiB
    Parted "mkpart primary linux-swap 1MiB 4GiB"
    SwapPartition="${GrubDevice}1"
    MakeSwap="Y"
    Parted "mkpart primary ext4 4GiB 100%"
    Parted "set 2 boot on"
    RootPartition="${GrubDevice}2"
    RootType="ext4"
  elif [ $DiskSize -gt 10 ]; then
    # Swap 2Gib and one main partition up to 16GiB
    Parted "mkpart primary linux-swap 1MiB 2GiB"
    SwapPartition="${GrubDevice}1"
    Parted "mkpart primary ext4 2GiB 100%"
    Parted "set 2 boot on"
    RootPartition="${GrubDevice}2"
    RootType="ext4"   
    SwapFile="2G"
    SwapPartition=""
  else # If disk < 10 Gb
    # Swap file and one main partition up to 10GiB
    Parted "mkpart primary ext4 1MiB 100%"
    Parted "set 1 boot on"
    RootPartition="${GrubDevice}1"
    RootType="ext4"
    SwapFile="2G"
    SwapPartition=""
  fi
  ShowPart1="Swap: `lsblk -l | grep "${UseDisk}1" | awk '{print $4}'`" >/dev/null
  ShowPart2=`lsblk -l | grep "${UseDisk}2" | awk '{print $4}'` >/dev/null
  ShowPart3=""
  if [ ${Home} = "Y" ]; then
    ShowPart3=`lsblk -l | grep "${UseDisk}3" | awk '{print $4}'` >/dev/null
    PrintHome"Home partition: ${AddPartList[0]} ${AddPartType[0]} $ShowPart3"
  fi
  AutoPart=1 # Set flag to 'on' for mounting 
  dialog --backtitle "$Backtitle" --title " auto-partition " \
    --msgbox "Partitioning of ${GrubDevice} successful\n\n$ShowPart1 ${SwapPartition}${SwapFile}\n $ShowPart2  ${RootPartition} ${RootType}\n$PrintHome\n\nYou will have the opportunity to review these later" 15 40
}

FileSystem() { 
  local NoCancel="--$1"
  dialog --backtitle "$Backtitle" --title " Partitioning " ${NoCancel}\
      --menu "\n$Message\n" 18 50 4 \
        "ext2" "-" \
        "ext3" "-" \
        "ext4" "-" \
        "btrfs" "-" 2> output.file
  if [ $? -gt 0 ]; then # If 'Cancel' selected
    PartitionType=""
  else
    PartitionType=$(cat output.file)
  fi
}

SetLabel() { # Called from the root, swap and extra partitions routines
# ... each passing a single argument containing the partition ID
# Build an associative array of partitions (LabellingArray[])
PartitionID=$1
local HowMany="${#PartitionArray[@]}"
local x=0
until [ ${x} -eq ${HowMany} ] # Until last record passed
do
  CompareID=`echo ${PartitionArray[${x}]} | awk '{print $1}'` # Get matching record number
  if [ -z ${CompareID} ]; then # If there are no records to compare
    x=$((x+1))                 # Advance the counter and get next iteration
    continue
  fi
  if [ ${CompareID} = ${PartitionID} ]; then # If the partition is in the array, it has a label
  Label=`echo ${PartitionArray[${x}]} | awk '{print $4}'` # Save the label
  # Label=`echo ${PartitionArray[${x}]}`
  fi
  x=$((x+1))
done
}

EditLabel() { # Called by AllocateRoot, AllocateSwap and MorePartitions
# Allows user to keep, edit or remove an existing label
Label="${Labelled[$1]}"
if [ -n ${Label} ]; then
  dialog --backtitle "$Backtitle" --title "  Edit Partition Label  " \
      --menu "The partition you have chosen is labelled '${Label}'" 18 50 3 \
        "1" "Keep existing label" \
        "2" "Delete label" \
        "3" "Enter a new label" 2> output.file
  Response=$(cat output.file)
  case $Response in
    1) LabellingArray[$PartitionID]=$Label # Keep saved label
    ;;
    2) LabellingArray[$PartitionID]="" # Empty label
    ;;
    *) dialog --backtitle "$Backtitle" --title " Edit Partition Label " \
      --inputbox "Enter the new name for $PartitionID" 10 50 2> output.file
      Response=$(cat output.file)
      LabellingArray[$PartitionID]=$Response # Save new label
  esac
fi
}

BuildPartitionLists() { # First called by CheckParts to generate details of partitions
  # for display, then by feliz to prepare partition arrays for selection for root, swap and others
  # 1) First get a list of all partitions up to sda99 | select first field | remove /dev/ | remove colon 
  ListTypeIDs=`sudo blkid /dev/sd* | grep ' TYPE' | awk '{print $1}' | cut -c 6- | sed s/://g`
  # Then get matching list of types, removing unwanted text (TYPE=) and quotes 
  ListTypes=`sudo blkid /dev/sd* | grep ' TYPE' | awk '{print $(NF-1)}' | cut -c 6- | sed s/\"//g` 
  # Add records from those two indexed arrays into the associative array
  local Counter=0
  for i in ${ListTypeIDs} 
  do
    x=0
    for l in ${ListTypes}
    do
      if [ $x -eq $Counter ]; then
        FileSystem[$i]=$l # ... get the matching type
      break
      fi
      x=$((x+1))
    done
    Counter=$((Counter+1))
  done
  # 2) Find all up to sd*99 with LABEL | select 1st field | remove /dev/ | remove colon
  ListLabelledIDs=`sudo blkid /dev/sd* | grep LABEL | awk '{print $1}' | cut -c 6- | sed s/://g`
  # If at least one labelled partition found, get a matching list of labels (remove quotes)
  if [ -n "$ListLabelledIDs" ]; then
    ListLabelledLabels=`sudo blkid /dev/sd* | grep LABEL | awk '{print $2}' | cut -c 7- | sed s/\"//g`
  fi
  # Add records from those two indexed arrays into associative array
  Counter=0
  for i in ${ListLabelledIDs}
  do
    x=0
    for l in ${ListLabelledLabels}
    do
      if [ $x -eq $Counter ]; then
        Labelled[$i]=$l # ... get the matching label
      break
      fi
      x=$((x+1))
    done
    Counter=$((Counter+1))
  done
  local HowManyLabelled="${#Labelled[@]}"
  # 3) Find any partitions flagged as bootable
  ListAll=`sudo sfdisk -l | grep /dev | grep '*' | awk '{print $1}' | cut -c 6-`
  declare -a Flagged
  Counter=0
  for i in $ListAll
  do
    Flagged[${Counter}]="$i"
    Counter=$((Counter+1))
  done
  local HowManyFlagged="${#Flagged[@]}"
  # 4) Prepare list of short identifiers (sda1 sda2 ...)
  PartitionList="" 
  ShowPartitions=`lsblk -l | grep 'part' | awk '{print $1}'`
  # 5) Run through short identifiers, checking the three arrays for a match
  Counter=0 # For count of partitions
  Label=""
  for part in ${ShowPartitions}
  do
  # First test Flagged
    local x=0
    until [ ${x} -eq ${HowManyFlagged} ]
    do
      if [ $part = "${Flagged[$x]}" ]; then
        Bootable="(Bootable)"
        break
      else
        Bootable=""
      fi
      x=$((x+1))
    done
    # Next test Labelled
    ThisPart=${Labelled[${part}]} # Find the record in Labelled that matches the current iteration
    if [ -n "${ThisPart}" ]; then
      Label="${ThisPart}"
    fi
    # Finally get the filesystem type
    ThisPart=${FileSystem[${part}]} # Find the record in FileSystem that matches the current iteration
    LongID=`lsblk -l | grep ${part} | awk '{print $1 " " $4 " " $7}'`
    PartitionArray[${Counter}]="$LongID $ThisPart ${Label} ${Bootable}"
    Label=""
    # Save the short ID for later functions
    PartitionList="${PartitionList} ${part}"
    (( Counter+=1 ))
  done
  PARTITIONS=${Counter}
}

UpdateArray() { # Remove the selected partition from $PartitionArray[]
  # Called by AllocateRoot, AllocateSwap and MorePartitions
	local Counter=0
  declare -a NewArray  # Empty NewArray
  # Build NewArray excluding the partition selected in the calling function
  for p in "${PartitionArray[@]}"
  do
    First=`echo $p | cut -c 1-5`
    if [ $First ]; then
      if [ ${PassPart} != ${First} ]; then
        NewArray[${Counter}]="$p"
        (( Counter+=1 ))
      fi
    fi
  done
  # Then copy NewArray into PartitionArray
  Counter=0
  for p in "${NewArray[@]}"
  do
    PartitionArray[${Counter}]=${NewArray[$Counter]}
    Counter=$((Counter+1))
  done
  unset PartitionArray[$Counter] # Delete the last element
}

AllocateRoot() {
  # Display partitions for user-selection	
	# Uses list of all available partitions in PartitionList
	Remaining=""
  Partition=""
	PartitionType=""
  local Message="Select a partition to use as /root\n"
  listgen2 "$PartitionList" " Partitions " "nocancel" "PartitionArray"
  Reply=$(cat output.file)
  PassPart="$Reply"
  SetLabel "$Reply"
  UpdateArray # Remove the selected partition from $PartitionArray[]
  local Counter=0  
  for i in ${PartitionList}
  do
		(( Counter+=1 ))
    if [ $i = $Reply ]; then
			Partition="$i"
			RootPartition="/dev/$i"
      # Before going to FileSystem, see if the partition is already formatted
      CheckPartition
      # Now select a filesystem
      if [ ${CurrentType} ]; then
        local Message="$Message\nYou can choose to leave it as it is, by selecting '<Cancel>', but be aware that not reformatting the root partition may have unexpected consequences."
        FileSystem
      else
        local Message="Please now select the file system for ${Partition} ... It is not recommended to mix the btrfs file-system with others.\n"
        FileSystem "nocancel" 
      fi
			if [ -z ${PartitionType} ] && [ ${CurrentType} ]; then
				RootType=""
			elif [ -z ${PartitionType} ]; then
				RootType="ext4"
			else
        RootType="${PartitionType}"
        Label="${Labelled[${PassPart}]}"
        if [ -n "${Label}" ]; then
          EditLabel $PassPart
        fi
      fi
		else
			Remaining="$Remaining $i"	# Add next available partition
		fi
	done
  PartitionList=$Remaining			# Replace original PartitionList with remaining options
}

CheckPartition() {
# Finds if there is an existing file system on the selected partition
CurrentType=`file -sL ${Partition} | grep "ext" | cut -c26-30`
if [ ${CurrentType} ]; then
  local Message="The selected partition ${Partition} is currently formatted to ${CurrentType}\nReformatting it will remove all data currently on it."
else
 local Message=""
fi
}

AllocateSwap() {
# ~ Checks if there are remaining partitions and allows selection for swap ~
if [ -n "${PartitionList}" ]         # Partitionlist as updated by AllocateRoot
then
  SwapPartition=""                   # Make sure other variables are empty
  SwapFile=""
  declare -a CopyArray               # Prepare empty array for passing to listgen2
  local Counter=0                    # Start counter at 1
  for p in "${PartitionArray[@]}"    # Copy each item from PartitionArray .....
  do
    CopyArray[${Counter}]=${PartitionArray[$Counter]} # ... into CopyArray for display in menu
    (( Counter+=1 ))                 # Counter is always 1 ahead of array elements
  done
                                     # Prepare for passing to listgen2
  CopyArray[${Counter}]="Swapfile"   # Add 'Swapfile' to array of available partitions
  PickFrom="$PartitionList Swapfile" # and make copy of PartitionList with 'Swapfile' added
  Width=50                           # Set window minimum width for listgen2
  local Message="Select a partition for swap, or allocate a swap file. Warning: Btrfs does not support swap files.\nIf you select <None> no swap will be allocated" # Passed to listgen2
  listgen2 "$PickFrom" "Partitions" "None" "CopyArray" # listgen2 builds complex dialog menu
  if [ $? -ne 0 ]; then              # If <Cancel> selected
    Result="Done"                    # Prepare reporting variable before exiting
    SwapPartition=""
    break
  fi
  Result=$(cat output.file)          # Save selected partition ID
  if [ $Result = "Swapfile" ]; then
    SetSwapFile                      # Function call to set swapfile size
    SwapPartition=""
    break
  else
    SwapPartition="/dev/$Result"     # All other options are a partition in form 'sd*n'
    IsSwap=`sudo blkid ${SwapPartition} | grep 'swap' | awk '{print $1}'` # Check if already a swap
    if [ -n "$IsSwap" ]; then                                     # If it is, offer yes/no ...
      dialog --backtitle "$Backtitle" --title " Swap Partition " --yesno "$Result is already formatted as a swap partition, do you wish to reformat it?" 10 40
      case $? in                     # ... and use $? (exit status) to set variable
      0) MakeSwap="Y"                # used during installation
      ;;
      *) MakeSwap="N"
      esac
    fi
    Label="${Labelled[${Result}]}"   # Recover the label found earlier (associative array index 'sd*n')
    if [ -n "${Label}" ]; then       # If there is a label one ...
      EditLabel "$Result"            # Pass partition ID to two functions
      SetLabel "$Result"
    fi
    PassPart="$Result"
    UpdateArray                      # Remove the selected partition ($Result) from $PartitionArray
    Remaining=""
    for p in "${PartitionArray[@]}"  # Then go through the array ...
    do
      First=`echo $p | awk '{print $1}'` # Separate first field, and use it
      Remaining="$Remaining $First"	     # in building the new list
    done
  fi
fi
PartitionList=$Remaining             # Replace original PartitionList with remaining options
}

SetSwapFile() {
LoopRepeat="Y"
local Message="Allocate the size of your swap file (M = Megabytes, G = Gigabytes) [eg: 512M or 2G]"
while [ ${LoopRepeat} = "Y" ]
do
  dialog --backtitle "$Backtitle" --title " auto-partition " \
      --inputbox "\n$Message\n" 18 50 2> output.file
  Response=$(cat output.file)
  RESPONSE="${Response^^}"
	# Check that entry includes 'M or G'
	CheckInput=(`echo $RESPONSE | grep "G\|M"`)
  echo
	if [ -z ${CheckInput} ]; then
    local Message="You must include M or G\n$Message"
		SwapFile=""
	else
    SwapFile=$RESPONSE
    LoopRepeat="N"
  fi
  if [ ${LoopRepeat} = "N" ]; then
    break
  fi 
done 
}

MorePartitions() { # For any unallocated partitions. Uses PartitionList and PartitionArray
  #  as updated by AllocateSwap()
  local Elements=0
  AddedToRemaining=0
  for i in ${PartitionList}
  do
    (( Elements+=1 ))
  done
  while [ $Elements -gt 0 ]  
  do
    Remaining=""
    local Message="The following partitions remain unallocated.\nIf you wish to use one, select it from the list, or choose <Cancel> to finish partitioning."
    listgen2 "$PartitionList" "Partitions" "" "PartitionArray"
    Response=$?
    if [ $Response -gt 0 ]; then # ie: <Cancel>
      Elements=0
      break
    else
      Result=`cat output.file`
      PassPart=$Result
      SetLabel "$Result"
      UpdateArray # Remove the selected partition from $PartitionArray[]
    fi
    for Part in ${PartitionList} # Iterate through the list to find selected item
    do
      Partition=""
      PartitionType=""
      if [ $Part = $Result ]; then
        Partition="/dev/$Part"
        MakePartition # Call complete details
        Label="${Labelled[${PassPart}]}"
        if [ -n "${Label}" ]; then
          EditLabel $PassPart
        fi
      else # This part is not selected
        Remaining="$Remaining $Part" # Add unused partition to temp list
        (( AddedToRemaining+=1 )) # And increment the count
      fi
    done
    PartitionList=$Remaining	# Replace original PartitionList with temp list
    Elements=$AddedToRemaining
  done
  # Ensure that if AddPartList (the defining array) is empty, all others are too
  if [ -z ${#AddPartList[@]} ]
  then
    AddPartList=""
    AddPartMount=""
    AddPartType=""
  fi
}

MakePartition() { # Called by MorePartitions
  # Add the selected partition to the array for extra partitions
  # 1) Save to AddPartList (eg: /dev/sda5)
	ExtraPartitions=${#AddPartList[@]}
	AddPartList[$ExtraPartitions]="${Partition}"
  CheckPartition   # Before going to FileSystem, check the partition
  if [ ${CurrentType} ]; then
    local Message="You can choose to leave it as it is, by selecting 'Done', but not reformatting an existing partition can have unexpected consequences."
  fi
  # 2) Select filesystem
  TypeList="ext2 ext3 ext4 btrfs" # Set format types for the selected partition
	FileSystem
	AddPartType[$ExtraPartitions]="${PartitionType}" 	# Add it to AddPartType list  
  # 3) Get a mountpoint
	LoopRepeat="Y"
  local Message="Enter a mountpoint for ${Partition} (eg: '/home')"
	while [ ${LoopRepeat} = "Y" ]
	do
    dialog --backtitle "$Backtitle" --title " auto-partition " \
      --inputbox "\n$Message\n" 18 50 2> output.file
    Response=$(cat output.file)
 		# Check that entry includes '/'
		CheckInput=(`echo $Response | cut -c1`)
		case ${CheckInput} in
      "") PrintOne "You must enter a valid name"
					PartMount=""
          ;;
			*) if [ ${CheckInput} != "/" ]; then
						PartMount="/${Response}"
				else
						PartMount="${Response}"
				fi
    esac
    # Check that the mountpoint has not already been used
		MountPointCounter=0
		if [ -z ${AddPartMount} ]; then
			LoopRepeat="N"
		else
      # Go through AddPartMount checking each item against PartMount
			for MountPoint in ${AddPartMount}
			do 
				MountPointCounter=$((MountPointCounter+1))
				if [ $MountPoint = $PartMount ]; then
					local Message="Mountpoint ${PartMount} has already been used. Please use a different mountpoint.\n$Message"
				else
					LoopRepeat="N"
					break
				fi
			done 
		fi 
		if [ ${LoopRepeat} = "N" ]  
		then
			break
		fi 
	done 
	AddPartMount[$ExtraPartitions]="${PartMount}"
}
